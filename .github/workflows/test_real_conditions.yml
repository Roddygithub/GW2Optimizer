name: ðŸ§ª GW2Optimizer - Real Conditions E2E Test

on:
  push:
    branches:
      - main
      - dev
  workflow_dispatch:
  schedule:
    - cron: "0 4 * * *"  # Tous les jours Ã  4h du matin

jobs:
  e2e-test:
    name: ðŸš€ Full Real Conditions Test (Mistral + GW2 API)
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    # PostgreSQL dÃ©sactivÃ© temporairement en attendant la rÃ©solution des problÃ¨mes
    # services:
    #   postgres:
    #     image: postgres:16
    #     env:
    #       POSTGRES_USER: postgres
    #       POSTGRES_PASSWORD: postgres
    #       POSTGRES_DB: gw2_test
    #     ports: ["5432:5432"]
    #     options: >-
    #       --health-cmd="pg_isready -U postgres -d gw2_test"
    #       --health-interval=10s
    #       --health-timeout=5s
    #       --health-retries=10

    env:
      ENVIRONMENT: test
      MISTRAL_API_KEY: ${{ secrets.MISTRAL_API_KEY }}
      GW2_API_KEY: ${{ secrets.GW2_API_KEY }}
      # Utilisation de SQLite comme solution temporaire
      DATABASE_URL: sqlite+aiosqlite:///./gw2optimizer_test.db
      REDIS_ENABLED: "false"
      SECRET_KEY: test-secret-key-e2e-only
      ALGORITHM: HS256
      ACCESS_TOKEN_EXPIRE_MINUTES: 30
      PYTHONUNBUFFERED: "1"
      PYTHONPATH: "${{ github.workspace }}/backend"

    steps:
      # ðŸ§© 1ï¸âƒ£ Checkout du code
      - name: ðŸ§© Checkout repository
        uses: actions/checkout@v4

      # ðŸ§° 2ï¸âƒ£ Setup Python pour le backend
      - name: ðŸ Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: 'pip'

      # âš™ï¸ 3ï¸âƒ£ Setup Node.js pour le frontend
      - name: âš™ï¸ Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      # ðŸ”§ 4ï¸âƒ£ Installation des dÃ©pendances systÃ¨me et Python
      - name: ðŸ”§ Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc python3-dev libpq-dev

      # ðŸ“¦ 5ï¸âƒ£ Installation des dÃ©pendances backend
      - name: ðŸ“¦ Install backend dependencies
        run: |
          cd backend
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
          pip install asyncpg  # Pour le support asynchrone de PostgreSQL

      # ðŸ§  5ï¸âƒ£ Installation des dÃ©pendances frontend
      - name: ðŸ“¦ Install frontend dependencies
        run: |
          cd frontend
          npm ci

      # â³ 6ï¸âƒ£ Initialisation de SQLite (pas d'attente nÃ©cessaire)

      # ðŸ—„ï¸ 7ï¸âƒ£ Initialisation de la base de donnÃ©es SQLite
      - name: ðŸ—„ï¸ Initialize SQLite database
        working-directory: backend
        run: |
          python -c "
          import asyncio
          import os
          from sqlalchemy import text
          
          # Configuration pour SQLite
          db_path = './gw2optimizer_test.db'
          if os.path.exists(db_path):
              os.remove(db_path)
              print(f'ðŸ—‘ï¸  Removed existing database at {db_path}')
          
          async def init_db():
              # Importation diffÃ©rÃ©e pour Ã©viter les problÃ¨mes de boucle d'import
              from app.db.base_class import Base
              from app.db.session import async_engine
              from app.db import models  # noqa: F401
              
              print('ðŸ”„ Creating SQLite database tables...')
              
              # CrÃ©ation des tables
              async with async_engine.begin() as conn:
                  await conn.run_sync(Base.metadata.create_all)
              
              # VÃ©rification de la connexion
              async with async_engine.connect() as conn:
                  result = await conn.execute(text('SELECT 1'))
                  print(f'âœ… SQLite connection test: {result.scalar() == 1}')
          
          try:
              asyncio.run(init_db())
              print('âœ… SQLite database initialized successfully')
          except Exception as e:
              print(f'âŒ SQLite database initialization failed: {str(e)}')
              import traceback
              traceback.print_exc()
              raise
          "

      # ðŸ”§ 7ï¸âƒ£ DÃ©marrage des services backend et frontend
      - name: ðŸ”§ Start backend and frontend
        run: |
          cd backend
          nohup uvicorn app.main:app --host 0.0.0.0 --port 8000 > backend.log 2>&1 &
          echo $! > backend.pid
          
          cd ../frontend
          nohup npm run dev -- --host 0.0.0.0 --port 5173 > frontend.log 2>&1 &
          echo $! > frontend.pid
          
          echo "â³ Waiting for services to start..."
          sleep 15

      # ðŸ¥ 8ï¸âƒ£ Health checks
      - name: ðŸ¥ Health check backend
        run: |
          max_attempts=30
          attempt=0
          until curl -f http://localhost:8000/health || [ $attempt -eq $max_attempts ]; do
            echo "â³ Waiting for backend... ($attempt/$max_attempts)"
            sleep 2
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -eq $max_attempts ]; then
            echo "âŒ Backend health check failed"
            cat backend/backend.log
            exit 1
          fi
          
          echo "âœ… Backend is healthy"

      - name: ðŸ¥ Health check frontend
        run: |
          max_attempts=30
          attempt=0
          until curl -f http://localhost:5173 || [ $attempt -eq $max_attempts ]; do
            echo "â³ Waiting for frontend... ($attempt/$max_attempts)"
            sleep 2
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -eq $max_attempts ]; then
            echo "âŒ Frontend health check failed"
            cat frontend/frontend.log
            exit 1
          fi
          
          echo "âœ… Frontend is healthy"

      # ðŸ¤– 9ï¸âƒ£ ExÃ©cution du test en condition rÃ©elle
      - name: ðŸ§ª Run Real Conditions Test
        run: |
          chmod +x test_real_conditions_extended.sh
          ./test_real_conditions_extended.sh

      # ðŸ“ˆ ðŸ”Ÿ Upload des rapports de test
      - name: ðŸ“Š Upload Test Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gw2optimizer-test-report
          path: test_report.txt
          retention-days: 30

      # ðŸ” 1ï¸âƒ£1ï¸âƒ£ Upload des logs
      - name: ðŸ“œ Upload Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gw2optimizer-logs
          path: |
            backend/backend.log
            frontend/frontend.log
            response.json
            gw2optimizer_test.db
          retention-days: 30

      # ðŸ§¹ 1ï¸âƒ£2ï¸âƒ£ Cleanup
      - name: ðŸ§¹ Cleanup services
        if: always()
        run: |
          if [ -f backend/backend.pid ]; then
            kill "$(cat backend/backend.pid)" 2>/dev/null || true
          fi
          if [ -f frontend/frontend.pid ]; then
            kill "$(cat frontend/frontend.pid)" 2>/dev/null || true
          fi
