name: ðŸ§ª GW2Optimizer - Real Conditions E2E Test

on:
  push:
    branches:
      - main
      - dev
  workflow_dispatch:
  schedule:
    - cron: "0 4 * * *"  # Tous les jours Ã  4h du matin

jobs:
  e2e-test:
    name: ðŸš€ Full Real Conditions Test (Mistral + GW2 API)
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: gw2_test
        ports: ["5432:5432"]
        options: >-
          --health-cmd="pg_isready -U postgres -d gw2_test"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=10

    env:
      ENVIRONMENT: test
      MISTRAL_API_KEY: ${{ secrets.MISTRAL_API_KEY }}
      GW2_API_KEY: ${{ secrets.GW2_API_KEY }}
      DATABASE_URL: postgresql+asyncpg://postgres:postgres@localhost:5432/gw2_test
      REDIS_ENABLED: "false"
      SECRET_KEY: test-secret-key-e2e-only
      ALGORITHM: HS256
      ACCESS_TOKEN_EXPIRE_MINUTES: 30
      PYTHONUNBUFFERED: "1"
      PYTHONPATH: "${{ github.workspace }}/backend"

    steps:
      # ðŸ§© 1ï¸âƒ£ Checkout du code
      - name: ðŸ§© Checkout repository
        uses: actions/checkout@v4

      # ðŸ§° 2ï¸âƒ£ Setup Python pour le backend
      - name: ðŸ Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: 'pip'

      # âš™ï¸ 3ï¸âƒ£ Setup Node.js pour le frontend
      - name: âš™ï¸ Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      # ðŸ”§ 4ï¸âƒ£ Installation des dÃ©pendances systÃ¨me et Python
      - name: ðŸ”§ Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc python3-dev libpq-dev

      # ðŸ“¦ 5ï¸âƒ£ Installation des dÃ©pendances backend
      - name: ðŸ“¦ Install backend dependencies
        run: |
          cd backend
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
          pip install asyncpg  # Pour le support asynchrone de PostgreSQL

      # ðŸ§  5ï¸âƒ£ Installation des dÃ©pendances frontend
      - name: ðŸ“¦ Install frontend dependencies
        run: |
          cd frontend
          npm ci

      # â³ 6ï¸âƒ£ Attente de la base de donnÃ©es
      - name: â³ Wait for PostgreSQL
        run: |
          for i in {1..30}; do
            if pg_isready -h localhost -p 5432 -U postgres -d gw2_test; then
              echo "âœ… PostgreSQL is ready"
              exit 0
            fi
            echo "â³ Waiting for PostgreSQL to be ready... (attempt $i/30)"
            sleep 2
          done
          echo "âŒ PostgreSQL not ready after 60 seconds"
          exit 1

      # ðŸ—„ï¸ 7ï¸âƒ£ Initialisation de la base de donnÃ©es
      - name: ðŸ—„ï¸ Initialize test database
        working-directory: backend
        run: |
          python -c "
          import asyncio
          import os
          from sqlalchemy import text
          from sqlalchemy.ext.asyncio import create_async_engine
          
          DATABASE_URL = os.getenv('DATABASE_URL')
          
          async def init_db():
              # Configuration de la base de donnÃ©es
              from app.db.base_class import Base
              from app.db.base import engine, get_db
              from app.db.session import async_session_maker
              
              # Importer tous les modÃ¨les
              from app.db import models  # noqa: F401
              
              print('ðŸ”„ Creating database tables...')
              
              # CrÃ©ation des tables
              async with engine.begin() as conn:
                  await conn.run_sync(Base.metadata.drop_all)
                  await conn.run_sync(Base.metadata.create_all)
              
              # VÃ©rification de la connexion
              async with async_session_maker() as session:
                  result = await session.execute(text('SELECT 1'))
                  print(f'âœ… Database connection test: {result.scalar() == 1}')
          
          try:
              asyncio.run(init_db())
              print('âœ… Database initialized successfully')
          except Exception as e:
              print(f'âŒ Database initialization failed: {str(e)}')
              import traceback
              traceback.print_exc()
              raise
          "

      # ðŸ”§ 7ï¸âƒ£ DÃ©marrage des services backend et frontend
      - name: ðŸ”§ Start backend and frontend
        run: |
          cd backend
          nohup uvicorn app.main:app --host 0.0.0.0 --port 8000 > backend.log 2>&1 &
          echo $! > backend.pid
          
          cd ../frontend
          nohup npm run dev -- --host 0.0.0.0 --port 5173 > frontend.log 2>&1 &
          echo $! > frontend.pid
          
          echo "â³ Waiting for services to start..."
          sleep 15

      # ðŸ¥ 8ï¸âƒ£ Health checks
      - name: ðŸ¥ Health check backend
        run: |
          max_attempts=30
          attempt=0
          until curl -f http://localhost:8000/health || [ $attempt -eq $max_attempts ]; do
            echo "â³ Waiting for backend... ($attempt/$max_attempts)"
            sleep 2
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -eq $max_attempts ]; then
            echo "âŒ Backend health check failed"
            cat backend/backend.log
            exit 1
          fi
          
          echo "âœ… Backend is healthy"

      - name: ðŸ¥ Health check frontend
        run: |
          max_attempts=30
          attempt=0
          until curl -f http://localhost:5173 || [ $attempt -eq $max_attempts ]; do
            echo "â³ Waiting for frontend... ($attempt/$max_attempts)"
            sleep 2
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -eq $max_attempts ]; then
            echo "âŒ Frontend health check failed"
            cat frontend/frontend.log
            exit 1
          fi
          
          echo "âœ… Frontend is healthy"

      # ðŸ¤– 9ï¸âƒ£ ExÃ©cution du test en condition rÃ©elle
      - name: ðŸ§ª Run Real Conditions Test
        run: |
          chmod +x test_real_conditions_extended.sh
          ./test_real_conditions_extended.sh

      # ðŸ“ˆ ðŸ”Ÿ Upload des rapports de test
      - name: ðŸ“Š Upload Test Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gw2optimizer-test-report
          path: test_report.txt
          retention-days: 30

      # ðŸ” 1ï¸âƒ£1ï¸âƒ£ Upload des logs
      - name: ðŸ“œ Upload Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gw2optimizer-logs
          path: |
            backend/backend.log
            frontend/frontend.log
            response.json
            gw2optimizer_test.db
          retention-days: 30

      # ðŸ§¹ 1ï¸âƒ£2ï¸âƒ£ Cleanup
      - name: ðŸ§¹ Cleanup services
        if: always()
        run: |
          if [ -f backend/backend.pid ]; then
            kill "$(cat backend/backend.pid)" 2>/dev/null || true
          fi
          if [ -f frontend/frontend.pid ]; then
            kill "$(cat frontend/frontend.pid)" 2>/dev/null || true
          fi
