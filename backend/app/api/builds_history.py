"""API endpoints for build suggestion history."""

from __future__ import annotations

from typing import Optional

from fastapi import APIRouter, Depends, Query, status
from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.security import get_current_user_optional
from app.db.base import get_db
from app.db.models import UserDB
from app.models.build_suggestion import BuildSuggestionDB
from app.schemas.builds import BuildSuggestionCreate, BuildSuggestionOut, PaginatedBuildSuggestions

router = APIRouter(prefix="/history", tags=["Build Suggestions"])


@router.post("", response_model=BuildSuggestionOut, status_code=status.HTTP_201_CREATED)
async def create_build_suggestion(
    payload: BuildSuggestionCreate,
    current_user: Optional[UserDB] = Depends(get_current_user_optional),
    db: AsyncSession = Depends(get_db),
) -> BuildSuggestionOut:
    """Persist a build suggestion generated by the AI."""

    suggestion = BuildSuggestionDB(
        user_id=getattr(current_user, "id", None),
        build=payload.build,
        explanation=payload.explanation,
    )
    db.add(suggestion)
    await db.commit()
    await db.refresh(suggestion)

    return BuildSuggestionOut.model_validate(suggestion)


@router.get("", response_model=PaginatedBuildSuggestions, status_code=status.HTTP_200_OK)
async def list_build_suggestions(
    page: int = Query(1, ge=1, description="Page number (starts at 1)"),
    limit: int = Query(20, ge=1, le=100, description="Number of items per page"),
    current_user: Optional[UserDB] = Depends(get_current_user_optional),
    db: AsyncSession = Depends(get_db),
) -> PaginatedBuildSuggestions:
    """Return paginated build suggestions for the current context."""

    # Anonymes et auth retournent 200 avec liste vide ou items
    filters = []
    if current_user:
        filters.append(BuildSuggestionDB.user_id == current_user.id)
    else:
        # Anonymes: retourner items avec user_id IS NULL
        filters.append(BuildSuggestionDB.user_id.is_(None))

    total_stmt = select(func.count()).select_from(BuildSuggestionDB).where(*filters)
    total = (await db.execute(total_stmt)).scalar_one()

    stmt = (
        select(BuildSuggestionDB)
        .where(*filters)
        .order_by(BuildSuggestionDB.created_at.desc())
        .offset((page - 1) * limit)
        .limit(limit)
    )
    result = await db.execute(stmt)
    records = result.scalars().all()

    items = [BuildSuggestionOut.model_validate(record) for record in records]
    has_next = page * limit < total

    return PaginatedBuildSuggestions(
        items=items,
        total=total,
        page=page,
        limit=limit,
        has_next=has_next,
    )
