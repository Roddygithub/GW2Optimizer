"""Legacy stateless BuildService retained for AI endpoints."""

from datetime import datetime
import uuid
from typing import List, Optional

from app.models.build import Build, BuildCreate, BuildResponse


class BuildService:
    """Minimal stateless service used by AI-specific routes."""

    def __init__(self) -> None:
        self.builds_cache: dict[str, Build] = {}

    async def create_build(self, request: BuildCreate) -> BuildResponse:
        build = await self._generate_build_with_ai(request)
        if not build.id:
            build.id = str(uuid.uuid4())
        build.created_at = datetime.utcnow()
        build.updated_at = datetime.utcnow()
        self.builds_cache[build.id] = build
        return BuildResponse(build=build, ai_analysis=None, similar_builds=[])

    async def get_build(self, build_id: str) -> Optional[Build]:
        return self.builds_cache.get(build_id)

    async def list_builds(self, limit: int = 20) -> List[Build]:
        return list(self.builds_cache.values())[:limit]

    async def _generate_build_with_ai(self, request: BuildCreate) -> Build:
        return Build(
            id=str(uuid.uuid4()),
            user_id="ai",
            name=request.name or "AI Generated Build",
            profession=request.profession,
            specialization=request.specialization,
            game_mode=request.game_mode,
            role=request.role,
            description=request.description or "Generated by AI",
            playstyle=request.playstyle,
            source_type=request.source_type or "ai",
            effectiveness=request.effectiveness,
            difficulty=request.difficulty,
            is_public=request.is_public,
            trait_lines=request.trait_lines,
            skills=request.skills,
            equipment=request.equipment,
            synergies=request.synergies,
            counters=request.counters,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow(),
        )
